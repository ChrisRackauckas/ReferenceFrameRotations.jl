<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Reference Frame Rotations</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Reference Frame Rotations logo"/></a><h1>Reference Frame Rotations</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../man/euler_angle_axis/">Euler Angle and Axis</a></li><li><a class="toctext" href="../../man/euler_angles/">Euler Angles</a></li><li><a class="toctext" href="../../man/quaternions/">Quaternions</a></li><li><a class="toctext" href="../../man/conversions/">Conversions</a></li><li><a class="toctext" href="../../man/kinematics/">Kinematics</a></li><li><a class="toctext" href="../../man/composing_rotations/">Composing rotations</a></li><li><a class="toctext" href="../../man/inv_rotations/">Inverting rotations</a></li><li class="current"><a class="toctext" href>Library</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Library</a></li></ul><a class="edit-page" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/master/docs/src/lib/library.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Library</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Library-1" href="#Library-1">Library</a></h1><p>Documentation for <code>ReferenceFrameRotations.jl</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.DCM" href="#ReferenceFrameRotations.DCM"><code>ReferenceFrameRotations.DCM</code></a> — <span class="docstring-category">Type</span>.</div><div><p>The Direction Cosine Matrice is a <code>SMatrix{3,3}</code>, which is a 3x3 static matrix.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/ReferenceFrameRotations.jl#L20-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.EulerAngleAxis" href="#ReferenceFrameRotations.EulerAngleAxis"><code>ReferenceFrameRotations.EulerAngleAxis</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">struct EulerAngleAxis{T&lt;:Real}</code></pre><p>The definition of Euler Angle and Axis to represent a 3D rotation.</p><ul><li><p><code>a</code>: The Euler angle [rad].</p></li><li><p><code>v</code>: The unitary vector aligned with the Euler axis.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/ReferenceFrameRotations.jl#L45-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.EulerAngles" href="#ReferenceFrameRotations.EulerAngles"><code>ReferenceFrameRotations.EulerAngles</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">struct EulerAngles{T&lt;:Real}</code></pre><p>The definition of Euler Angles, which is composed of three angles <code>a1</code>, <code>a2</code>, and <code>a3</code> together with a rotation sequence <code>rot_seq</code>. The latter is provided by a symbol with three characters, each one indicating the rotation axis of the corresponding angle (for example, <code>:ZYX</code>). The valid values for <code>rot_seq</code> are:</p><ul><li><p><code>:XYX</code>, <code>:XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>ZYZ</code>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/ReferenceFrameRotations.jl#L26-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion" href="#ReferenceFrameRotations.Quaternion"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>struct Quaternion{T&lt;:Real}</strong></p><p>The definition of the quaternion. It has four values of the same type. The quaternion representation is:</p><pre><code class="language-none">q0 + q1.i + q2.j + q3.k</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/ReferenceFrameRotations.jl#L59-L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion-NTuple{4,Number}" href="#ReferenceFrameRotations.Quaternion-NTuple{4,Number}"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function Quaternion(q0::Number, q1::Number, q2::Number, q3::Number)</code></pre><p>Create the following quaternion:</p><pre><code class="language-none">q0 + q1.i + q2.j + q3.k</code></pre><p><strong>Args</strong></p><ul><li><p><code>q0</code>: Real part of the quaternion.</p></li><li><p><code>q1</code>: X component of the quaternion vectorial part.</p></li><li><p><code>q2</code>: Y component of the quaternion vectorial part.</p></li><li><p><code>q3</code>: Z component of the quaternion vectorial part.</p></li></ul><p><strong>Returns</strong></p><p>The new quaternion.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L11-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion-Tuple{AbstractArray{T,1} where T}" href="#ReferenceFrameRotations.Quaternion-Tuple{AbstractArray{T,1} where T}"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function Quaternion(v::Vector{T}) where T&lt;:Real</code></pre><p>If the vector <code>v</code> has 3 components, then create a quaternion in which the real part is <code>0</code> and the vectorial or imaginary part has the same components of the vector <code>v</code>. In other words:</p><pre><code class="language-none">q = 0 + v[1].i + v[2].j + v[3].k</code></pre><p>Otherwise, if the vector <code>v</code> has 4 components, then create a quaternion in which the elements match those of the input vector:</p><pre><code class="language-none">q = v[1] + v[2].i + v[3].j + v[4].k</code></pre><p><strong>Args</strong></p><ul><li><p><code>v</code>: Input vector. It must have three or four components.</p></li></ul><p><strong>Returns</strong></p><p>If <code>v</code> has three components, then it returns the quaternion in which the real part is <code>0</code> and the imaginary part is <code>v</code>. Otherwise, it returns the quaternion with real part <code>v[1]</code> and imaginary part <code>v[2:4]</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L35-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion-Tuple{Number,AbstractArray{T,1} where T}" href="#ReferenceFrameRotations.Quaternion-Tuple{Number,AbstractArray{T,1} where T}"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function Quaternion(r::Number, v::AbstractVector)</code></pre><p>Create a quaternion with real part <code>r</code> and vectorial or imaginary part <code>v</code>.</p><p><strong>Args</strong></p><ul><li><p><code>r</code>: Real part.</p></li><li><p><code>v</code>: Vectorial or imaginary part.</p></li></ul><p><strong>Returns</strong></p><p>The quaternion <code>r + v[1].i + v[2].j + v[3].k</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L73-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle2dcm" href="#ReferenceFrameRotations.angle2dcm"><code>ReferenceFrameRotations.angle2dcm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">function angle2dcm(angle_r1::Number, angle_r2::Number, angle_r3::Number, rot_seq::Symbol = :ZYX)</code></pre><p>Convert the Euler angles <code>angle_r1</code>, <code>angle_r2</code>, and <code>angle_r3</code> with the rotation sequence <code>rot_seq</code> to a direction cosine matrix.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>.</p><p><strong>Args</strong></p><ul><li><p><code>angle_r1</code>: Angle of the first rotation [rad].</p></li><li><p><code>angle_r2</code>: Angle of the second rotation [rad].</p></li><li><p><code>angle_r3</code>: Angle of the third rotation [rad].</p></li><li><p><code>rot_seq</code>: (OPTIONAL) Rotation sequence (<strong>Default</strong> = <code>:ZYX</code>).</p></li></ul><p><strong>Returns</strong></p><p>The direction cosine matrix.</p><p><strong>Remarks</strong></p><p>This function assigns <code>dcm = A3 * A2 * A1</code> in which <code>Ai</code> is the DCM related with the <em>i</em>-th rotation, <code>i Є [1,2,3]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">dcm = angle2dcm(pi/2, pi/3, pi/4, :ZYX)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/euler_angles.jl#L15-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle2dcm-Tuple{ReferenceFrameRotations.EulerAngles}" href="#ReferenceFrameRotations.angle2dcm-Tuple{ReferenceFrameRotations.EulerAngles}"><code>ReferenceFrameRotations.angle2dcm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function angle2dcm(eulerang::EulerAngles)</code></pre><p>Convert the Euler angles <code>eulerang</code> (see <code>EulerAngles</code>) to a direction cosine matrix.</p><p><strong>Args</strong></p><ul><li><p><code>eulerang</code>: Euler angles (see <code>EulerAngles</code>).</p></li></ul><p><strong>Returns</strong></p><p>The direction cosine matrix.</p><p><strong>Remarks</strong></p><p>This function assigns <code>dcm = A3 * A2 * A1</code> in which <code>Ai</code> is the DCM related with the <em>i</em>-th rotation, <code>i Є [1,2,3]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; angle2dcm(EulerAngles(pi/2, pi/3, pi/4, :ZYX))
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/euler_angles.jl#L130-L159">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle2quat" href="#ReferenceFrameRotations.angle2quat"><code>ReferenceFrameRotations.angle2quat</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">function angle2quat(angle_r1::Number, angle_r2::Number, angle_r3::Number, rot_seq::AbstractString=&quot;ZYX&quot;)</code></pre><p>Convert the Euler angles <code>angle_r1</code>, <code>angle_r2</code>, and <code>angle_r3</code> with the rotation sequence <code>rot_seq</code> to a quaternion.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>.</p><p><strong>Args</strong></p><ul><li><p><code>angle_r1</code>: Angle of the first rotation [rad].</p></li><li><p><code>angle_r2</code>: Angle of the second rotation [rad].</p></li><li><p><code>angle_r3</code>: Angle of the third rotation [rad].</p></li><li><p><code>rot_seq</code>: (OPTIONAL) Rotation sequence (<strong>Default</strong> = <code>:ZYX</code>).</p></li></ul><p><strong>Returns</strong></p><p>The quaternion.</p><p><strong>Remarks</strong></p><p>This function assigns <code>q = q1 * q2 * q3</code> in which <code>qi</code> is the quaternion related with the <em>i</em>-th rotation, <code>i Є [1,2,3]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; angle2quat(pi/2, pi/3, pi/4, :ZYX)
Quaternion{Float64}:
  + 0.7010573846499779 - 0.09229595564125714.i + 0.5609855267969309.j + 0.43045933457687935.k</code></pre><hr/></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/euler_angles.jl#L207-L241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle2quat-Tuple{ReferenceFrameRotations.EulerAngles}" href="#ReferenceFrameRotations.angle2quat-Tuple{ReferenceFrameRotations.EulerAngles}"><code>ReferenceFrameRotations.angle2quat</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function angle2quat(eulerang::EulerAngles)</code></pre><p>Convert the Euler angles <code>eulerang</code> (see <code>EulerAngles</code>) to a quaternion.</p><p><strong>Args</strong></p><ul><li><p><code>eulerang</code>: Euler angles (see <code>EulerAngles</code>).</p></li></ul><p><strong>Returns</strong></p><p>The quaternion.</p><p><strong>Remarks</strong></p><p>This function assigns <code>q = q1 * q2 * q3</code> in which <code>qi</code> is the quaternion related with the <em>i</em>-th rotation, <code>i Є [1,2,3]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; angle2quat(pi/2, pi/3, pi/4, :ZYX)
Quaternion{Float64}:
  + 0.7010573846499779 - 0.09229595564125714.i + 0.5609855267969309.j + 0.43045933457687935.k</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/euler_angles.jl#L370-L396">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle2rot-Tuple{Number,Number,Number,Symbol}" href="#ReferenceFrameRotations.angle2rot-Tuple{Number,Number,Number,Symbol}"><code>ReferenceFrameRotations.angle2rot</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function angle2rot([T,] angle_r1::Number, angle_r2::Number, angle_r3::Number, rot_seq::Symbol = :ZYX)</code></pre><p>Convert the Euler angles <code>angle_r1</code>, <code>angle_r2</code>, and <code>angle_r3</code> with the rotation sequence <code>rot_seq</code> to a rotation description of type <code>T</code>, which can be <code>DCM</code> or <code>Quaternion</code>.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>.</p><p><strong>Args</strong></p><ul><li><p><code>T</code>: (OPTIONAL) Type of the rotation description (<strong>Default</strong> = <code>DCM</code>).</p></li><li><p><code>angle_r1</code>: Angle of the first rotation [rad].</p></li><li><p><code>angle_r2</code>: Angle of the second rotation [rad].</p></li><li><p><code>angle_r3</code>: Angle of the third rotation [rad].</p></li><li><p><code>rot_seq</code>: (OPTIONAL) Rotation sequence (<strong>Default</strong> = <code>:ZYX</code>).</p></li></ul><p><strong>Returns</strong></p><p>The rotation description according to the type <code>T</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dcm = angle2rot(pi/2, pi/3, pi/4, :ZYX)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553

julia&gt; q   = angle2rot(Quaternion,pi/2, pi/3, pi/4, :ZYX)
Quaternion{Float64}:
  + 0.7010573846499779 - 0.09229595564125714.i + 0.5609855267969309.j + 0.43045933457687935.k</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/euler_angles.jl#L447-L484">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle2rot-Tuple{ReferenceFrameRotations.EulerAngles}" href="#ReferenceFrameRotations.angle2rot-Tuple{ReferenceFrameRotations.EulerAngles}"><code>ReferenceFrameRotations.angle2rot</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function angle2rot([T,] angle_r1::Number, angle_r2::Number, angle_r3::Number, rot_seq::Symbol = :ZYX)</code></pre><p>Convert the Euler angles <code>eulerang</code> (see <code>EulerAngles</code>) to a rotation description of type <code>T</code>, which can be <code>DCM</code> or <code>Quaternion</code>.</p><p><strong>Args</strong></p><ul><li><p><code>T</code>: (OPTIONAL) Type of the rotation description (<strong>Default</strong> = <code>DCM</code>).</p></li><li><p><code>eulerang</code>: Euler angles (see <code>EulerAngles</code>).</p></li></ul><p><strong>Returns</strong></p><p>The rotation description according to the type <code>T</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dcm = angle2rot(EulerAngles(pi/2, pi/3, pi/4, :ZYX))
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553

julia&gt; q   = angle2rot(Quaternion,EulerAngles(pi/2, pi/3, pi/4, :ZYX))
Quaternion{Float64}:
  + 0.7010573846499779 - 0.09229595564125714.i + 0.5609855267969309.j +
  0.43045933457687935.k</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/euler_angles.jl#L502-L532">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angleaxis2quat-Tuple{Number,Array{T,1} where T}" href="#ReferenceFrameRotations.angleaxis2quat-Tuple{Number,Array{T,1} where T}"><code>ReferenceFrameRotations.angleaxis2quat</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function angleaxis2quat(a::Number, v::Vector)</code></pre><p>Convert the Euler angle <code>a</code> and Euler axis <code>v</code>, which must be a unit vector, to a quaternion.</p><p><strong>Args</strong></p><ul><li><p><code>a</code>: Euler angle [rad].</p></li><li><p><code>v</code>: Unit vector that is aligned with the Euler axis.</p></li></ul><p><strong>Returns</strong></p><p>A quaternion that represents the same rotation of the Euler angle and axis.</p><p><strong>Remarks</strong></p><p>It is expected that the vector <code>v</code> is unitary. However, no verification is performed inside the function. The user must handle this situation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1;1;1];

julia&gt; v /= norm(v);

julia&gt; angleaxis2quat(pi/2,v)
Quaternion{Float64}:
  + 0.7071067811865476 + 0.408248290463863.i + 0.408248290463863.j + 0.408248290463863.k</code></pre><hr/></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/euler_angle_axis.jl#L14-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angleaxis2quat-Union{Tuple{ReferenceFrameRotations.EulerAngleAxis{T}}, Tuple{T}} where T&lt;:Real" href="#ReferenceFrameRotations.angleaxis2quat-Union{Tuple{ReferenceFrameRotations.EulerAngleAxis{T}}, Tuple{T}} where T&lt;:Real"><code>ReferenceFrameRotations.angleaxis2quat</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function angleaxis2quat(angleaxis::EulerAngleAxis{T}) where T&lt;:Real</code></pre><p>Convert a Euler angle and Euler axis <code>angleaxis</code> (see <code>EulerAngleAxis</code>) to a quaternion.</p><p><strong>Args</strong></p><ul><li><p><code>angleaxis</code>: Structure of type <code>EulerAngleAxis</code> with the Euler angle [rad] and            a unit vector that is aligned with the Euler axis.</p></li></ul><p><strong>Returns</strong></p><p>A quaternion that represents the same rotation of the Euler angle and axis.</p><p><strong>Remarks</strong></p><p>It is expected that the vector <code>angleaxis.v</code> is unitary. However, no verification is performed inside the function. The user must handle this situation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1;1;1];

julia&gt; v /= norm(v);

julia&gt; angleaxis2quat(EulerAngleAxis(pi/2,v))
Quaternion{Float64}:
  + 0.7071067811865476 + 0.408248290463863.i + 0.408248290463863.j + 0.408248290463863.k</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/euler_angle_axis.jl#L57-L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.compose_rotation-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,L} where L where T}" href="#ReferenceFrameRotations.compose_rotation-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,L} where L where T}"><code>ReferenceFrameRotations.compose_rotation</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function compose_rotation(R1, [, R2, R3, R4, R5, ...])</code></pre><p>Compute a composed rotation using the rotations <code>R1</code>, <code>R2</code>, <code>R3</code>, <code>R4</code>, ..., in the following order:</p><pre><code class="language-none"> First rotation
 |
 |
R1 =&gt; R2 =&gt; R3 =&gt; R4 =&gt; ...
       |
       |
       Second rotation</code></pre><p>The rotations can be described by Direction Cosine Matrices or Quaternions. Notice, however, that all rotations <strong>must be</strong> of the same type (DCM or quaternion).</p><p>The output will have the same type as the inputs (DCM or quaternion).</p><p><strong>Args</strong></p><ul><li><p><code>R1</code>: First rotation (DCM or quaternion).</p></li><li><p><code>R2, R3, R4, R5, ...</code>: (OPTIONAL) Other rotations (DCMs or quaternions).</p></li></ul><p><strong>Returns</strong></p><p>The composed rotation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; D1 = angle2dcm(+pi/3,+pi/4,+pi/5,:ZYX);

julia&gt; D2 = angle2dcm(-pi/5,-pi/4,-pi/3,:XYZ);

julia&gt; compose_rotation(D1,D2)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 1.0          0.0          5.55112e-17
 0.0          1.0          5.55112e-17
 5.55112e-17  5.55112e-17  1.0

julia&gt; q1 = angle2quat(+pi/3,+pi/4,+pi/5,:ZYX);

julia&gt; q2 = angle2quat(-pi/5,-pi/4,-pi/3,:XYZ);

julia&gt; compose_rotation(q1,q2)
Quaternion{Float64}:
  + 1.0 + 0.0.i + 2.0816681711721685e-17.j + 5.551115123125783e-17.k</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/compose_rotations.jl#L7-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.create_rotation_matrix" href="#ReferenceFrameRotations.create_rotation_matrix"><code>ReferenceFrameRotations.create_rotation_matrix</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">function create_rotation_matrix(angle::Number, axis::Symbol = :X) where T&lt;:Real</code></pre><p>Compute a rotation matrix that rotates a coordinate frame about the axis <code>axis</code> by the angle <code>angle</code>.</p><p><strong>Args</strong></p><ul><li><p><code>angle</code>: Angle.</p></li><li><p><code>axis</code>: Axis, must be &#39;x&#39;, &#39;X&#39;, &#39;y&#39;, &#39;Y&#39;, &#39;z&#39;, or &#39;Z&#39;.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-jldocstest">julia&gt; create_rotation_matrix(pi/2, :X)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 1.0   0.0          0.0
 0.0   6.12323e-17  1.0
 0.0  -1.0          6.12323e-17</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/DCM.jl#L12-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.dcm2angle" href="#ReferenceFrameRotations.dcm2angle"><code>ReferenceFrameRotations.dcm2angle</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">function dcm2angle(dcm::DCM, rot_seq::Symbol=:ZYX)</code></pre><p>Convert the DCM <code>dcm</code> to Euler Angles given a rotation sequence <code>rot_seq</code>.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>.</p><p><strong>Args</strong></p><ul><li><p><code>DCM</code>: Direction Cosine Matrix.</p></li><li><p><code>rot_seq</code>: (OPTIONAL) Rotation sequence (<strong>Default</strong> = <code>:ZYX</code>).</p></li></ul><p><strong>Returns</strong></p><p>The Euler angles (see <code>EulerAngles</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; D = DCM([1. 0. 0.; 0. 0. -1; 0. -1 0.]);

julia&gt; dcm2angle(D,:XYZ)
ReferenceFrameRotations.EulerAngles{Float64}(1.5707963267948966, 0.0, -0.0, :XYZ)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/DCM.jl#L65-L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.dcm2quat-Union{Tuple{StaticArrays.SArray{Tuple{3,3},T,2,L} where L}, Tuple{T}} where T&lt;:Real" href="#ReferenceFrameRotations.dcm2quat-Union{Tuple{StaticArrays.SArray{Tuple{3,3},T,2,L} where L}, Tuple{T}} where T&lt;:Real"><code>ReferenceFrameRotations.dcm2quat</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function dcm2quat(dcm::DCM{T}) where T&lt;:Real</code></pre><p>Convert the DCM <code>dcm</code> to a quaternion.</p><p><strong>Args</strong></p><ul><li><p><code>dcm</code>: Direction Cosine Matrix that will be converted.</p></li></ul><p><strong>Returns</strong></p><p>The quaternion that represents the same rotation of the DCM <code>dcm</code>.</p><p><strong>Remarks</strong></p><p>By convention, the real part of the quaternion will always be positive. Moreover, the function does not check if <code>dcm</code> is a valid direction cosine matrix. This must be handle by the user.</p><p>This algorithm was obtained from:</p><pre><code class="language-none">http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/</code></pre><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dcm = angle2dcm(pi/2,0.0,0.0,:XYZ);

julia&gt; q   = dcm2quat(dcm)
Quaternion{Float64}:
  + 0.7071067811865476 + 0.7071067811865475.i + 0.0.j + 0.0.k</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/DCM.jl#L186-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.ddcm-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,L} where L where T,AbstractArray}" href="#ReferenceFrameRotations.ddcm-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,L} where L where T,AbstractArray}"><code>ReferenceFrameRotations.ddcm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function ddcm(Dba::DCM, wba_b::AbstractArray)</code></pre><p>Compute the time-derivative of the DCM <code>dcm</code> that rotates a reference frame <code>a</code> into alignment to the reference frame <code>b</code> in which the angular velocity of <code>b</code> with respect to <code>a</code>, and represented in <code>b</code>, is <code>wba_b</code>.</p><p><strong>Args</strong></p><ul><li><p><code>Dba</code>: DCM that rotates the reference frame <code>a</code> into alignment with the        reference frame <code>b</code>.</p></li><li><p><code>wba_b</code>: Angular velocity of the reference frame <code>a</code> with respect to the          reference frame <code>b</code> represented in the reference frame <code>b</code>.</p></li></ul><p><strong>Returns</strong></p><p>The time-derivative of the DCM <code>Dba</code> (3x3 matrix of type <code>SMatrix{3,3}</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; D = DCM(eye(3));

julia&gt; ddcm(D,[1;0;0])
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 0.0   0.0  0.0
 0.0   0.0  1.0
 0.0  -1.0  0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/DCM.jl#L278-L308">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.dquat-Union{Tuple{ReferenceFrameRotations.Quaternion{T1},AbstractArray{T2,1}}, Tuple{T1}, Tuple{T2}} where T1&lt;:Real where T2&lt;:Real" href="#ReferenceFrameRotations.dquat-Union{Tuple{ReferenceFrameRotations.Quaternion{T1},AbstractArray{T2,1}}, Tuple{T1}, Tuple{T2}} where T1&lt;:Real where T2&lt;:Real"><code>ReferenceFrameRotations.dquat</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function dquat(qba::Quaternion{T1}, wba_b::AbstractVector)</code></pre><p>Compute the time-derivative of the quaternion <code>qba</code> that rotates a reference frame <code>a</code> into alignment to the reference frame <code>b</code> in which the angular velocity of <code>b</code> with respect to <code>a</code>, and represented in <code>b</code>, is <code>wba_b</code>.</p><p><strong>Args</strong></p><ul><li><p><code>qba</code>: Quaternion that rotates the reference frame <code>a</code> into alignment with the        reference frame <code>b</code>.</p></li><li><p><code>wba_b</code>: Angular velocity of the reference frame <code>a</code> with respect to the          reference frame <code>b</code> represented in the reference frame <code>b</code>.</p></li></ul><p><strong>Returns</strong></p><p>The quaternion with the time-derivative of <code>qba</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = eye(Quaternion);

julia&gt; dquat(q,[1;0;0])
Quaternion{Float64}:
  + 0.0 + 0.5.i + 0.0.j + 0.0.k</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L751-L779">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.inv_rotation-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,L} where L where T}" href="#ReferenceFrameRotations.inv_rotation-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,L} where L where T}"><code>ReferenceFrameRotations.inv_rotation</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function inv_rotation(R)</code></pre><p>Compute the inverse rotation of <code>R</code>, which can be a Direction Cosine Matrix or Quaternion.</p><p>The output will have the same type as <code>R</code> (DCM or quaternion).</p><p><strong>Args</strong></p><ul><li><p><code>R</code>: Rotation that will be inversed.</p></li></ul><p><strong>Returns</strong></p><p>The inverse rotation.</p><p><strong>Remarks</strong></p><p>If <code>R</code> is a DCM, than its transpose is computed instead of its inverse to reduce the computational burden. The both are equal if the DCM has unit norm. This must be verified by the used.</p><p>If <code>R</code> is a quaternion, than its conjugate is computed instead of its inverse to reduce the computational burden. The both are equal if the quaternion has unit norm. This must be verified by the used.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; D = angle2dcm(+pi/3,+pi/4,+pi/5,:ZYX);

julia&gt; inv_rotation(D)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  0.353553  -0.492816  0.795068
  0.612372   0.764452  0.201527
 -0.707107   0.415627  0.572061

julia&gt; q = angle2quat(+pi/3,+pi/4,+pi/5,:ZYX);

julia&gt; inv_rotation(q)
Quaternion{Float64}:
  + 0.8200711519756747 - 0.06526868310243991.i - 0.45794027732580056.j - 0.336918398289752.k</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/inv_rotations.jl#L7-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.quat2angle" href="#ReferenceFrameRotations.quat2angle"><code>ReferenceFrameRotations.quat2angle</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">function quat2angle(q::Quaternion, rot_seq::Symbol = :ZYX)</code></pre><p>Convert the quaternion <code>q</code> to Euler Angles given a rotation sequence <code>rot_seq</code>.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>.</p><p><strong>Args</strong></p><ul><li><p><code>q</code>: Quaternion.</p></li><li><p><code>rot_seq</code>: (OPTIONAL) Rotation sequence (<strong>Default</strong> = <code>:ZYX</code>).</p></li></ul><p><strong>Returns</strong></p><p>The Euler angles (see <code>EulerAngles</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Quaternion(cosd(45/2), sind(45/2), 0, 0);

julia&gt; quat2angle(q,:XYZ)
ReferenceFrameRotations.EulerAngles{Float64}(0.7853981633974484, 0.0, -0.0, :XYZ)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L707-L734">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.quat2angleaxis-Tuple{ReferenceFrameRotations.Quaternion}" href="#ReferenceFrameRotations.quat2angleaxis-Tuple{ReferenceFrameRotations.Quaternion}"><code>ReferenceFrameRotations.quat2angleaxis</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function quat2angleaxis(q::Quaternion)</code></pre><p>Convert the quaternion <code>q</code> to a Euler angle and axis representation.</p><p><strong>Args</strong></p><ul><li><p><code>q</code>: The quaternion that will be converted.</p></li></ul><p><strong>Returns</strong></p><p>The Euler angle and axis (see <code>EulerAngleAxis</code>).</p><p><strong>Remarks</strong></p><p>This function will not fail if the quaternion norm is not 1. However, the meaning of the results will not be defined, because the input quaternion does not represent a 3D rotation. The user must handle such situations.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Quaternion(cosd(45/2), sind(45/2), 0, 0);

julia&gt; quat2angleaxis(q)
ReferenceFrameRotations.EulerAngleAxis{Float64}(0.7853981633974484, [1.0, 0.0, 0.0])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L667-L695">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.quat2dcm-Tuple{ReferenceFrameRotations.Quaternion}" href="#ReferenceFrameRotations.quat2dcm-Tuple{ReferenceFrameRotations.Quaternion}"><code>ReferenceFrameRotations.quat2dcm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function quat2dcm(q::Quaternion)</code></pre><p>Convert the quaternion <code>q</code> to a Direction Cosine Matrix.</p><p><strong>Args</strong></p><ul><li><p><code>q</code>: Quaternion.</p></li></ul><p><strong>Returns</strong></p><p>The Direction Cosine Matrix.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Quaternion(cosd(45/2), sind(45/2), 0, 0);

julia&gt; quat2dcm(q)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 1.0   0.0       0.0
 0.0   0.707107  0.707107
 0.0  -0.707107  0.707107</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L626-L651">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.smallangle2dcm-Tuple{Number,Number,Number}" href="#ReferenceFrameRotations.smallangle2dcm-Tuple{Number,Number,Number}"><code>ReferenceFrameRotations.smallangle2dcm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function smallangle2dcm(θx::Number, θy::Number, θz::Number)</code></pre><p>Create a direction cosine matrix from three small rotations of angles <code>θx</code>, <code>θy</code>, and <code>θz</code> about the axes X, Y, and Z, respectively.</p><p><strong>Args</strong></p><ul><li><p><code>θx</code>: Angle of the rotation about the X-axis [rad].</p></li><li><p><code>θy</code>: Angle of the rotation about the Y-axis [rad].</p></li><li><p><code>θz</code>: Angle of the rotation about the Z-axis [rad].</p></li></ul><p><strong>Returns</strong></p><p>The direction cosine matrix.</p><p><strong>Remarks</strong></p><p>No process of ortho-normalization is performed with the computed DCM.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; smallangle2dcm(+0.01, -0.01, +0.01)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  1.0    0.01  0.01
 -0.01   1.0   0.01
 -0.01  -0.01  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/euler_angles.jl#L167-L197">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.smallangle2quat-Tuple{Number,Number,Number}" href="#ReferenceFrameRotations.smallangle2quat-Tuple{Number,Number,Number}"><code>ReferenceFrameRotations.smallangle2quat</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function smallangle2quat(θx::Number, θy::Number, θz::Number)</code></pre><p>Create a quaternion from three small rotations of angles <code>θx</code>, <code>θy</code>, and <code>θz</code> about the axes X, Y, and Z, respectively.</p><p><strong>Args</strong></p><ul><li><p><code>θx</code>: Angle of the rotation about the X-axis [rad].</p></li><li><p><code>θy</code>: Angle of the rotation about the Y-axis [rad].</p></li><li><p><code>θz</code>: Angle of the rotation about the Z-axis [rad].</p></li></ul><p><strong>Returns</strong></p><p>The quaternion.</p><p><strong>Remarks</strong></p><p>The quaternion is normalized.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; smallangle2quat(+0.01, -0.01, +0.01)
Quaternion{Float64}:
  + 0.9999625021092433 + 0.004999812510546217.i - 0.004999812510546217.j + 0.004999812510546217.k</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/euler_angles.jl#L404-L432">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.smallangle2rot-Tuple{Number,Number,Number}" href="#ReferenceFrameRotations.smallangle2rot-Tuple{Number,Number,Number}"><code>ReferenceFrameRotations.smallangle2rot</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function smallangle2rot([T,] θx::Number, θy::Number, θz::Number)</code></pre><p>Create a rotation description of type <code>T</code> from three small rotations of angles <code>θx</code>, <code>θy</code>, and <code>θz</code> about the axes X, Y, and Z, respectively.</p><p>The type <code>T</code> of the rotation description can be <code>DCM</code> or <code>Quaternion</code>.</p><p><strong>Args</strong></p><ul><li><p><code>T</code>: (OPTIONAL) Type of the rotation description (<strong>Default</strong> = <code>DCM</code>).</p></li><li><p><code>θx</code>: Angle of the rotation about the X-axis [rad].</p></li><li><p><code>θy</code>: Angle of the rotation about the Y-axis [rad].</p></li><li><p><code>θz</code>: Angle of the rotation about the Z-axis [rad].</p></li></ul><p><strong>Returns</strong></p><p>The rotation description according to the type <code>T</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dcm = smallangle2rot(+0.01, -0.01, +0.01);

julia&gt; q   = smallangle2rot(Quaternion,+0.01, -0.01, +0.01);

julia&gt; dcm = smallangle2rot(+0.01, -0.01, +0.01)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  1.0    0.01  0.01
 -0.01   1.0   0.01
 -0.01  -0.01  1.0

julia&gt; q   = smallangle2rot(Quaternion,+0.01, -0.01, +0.01)
Quaternion{Float64}:
  + 0.9999625021092433 + 0.004999812510546217.i - 0.004999812510546217.j + 0.004999812510546217.k</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/euler_angles.jl#L542-L579">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.vect-Tuple{ReferenceFrameRotations.Quaternion}" href="#ReferenceFrameRotations.vect-Tuple{ReferenceFrameRotations.Quaternion}"><code>ReferenceFrameRotations.vect</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function vect(q::Quaternion{T}) where T&lt;:Real</code></pre><p>Return the vectorial or imaginary part of the quaternion represented by a 3x1 vector.</p><p><strong>Args</strong></p><ul><li><p><code>q</code>: Quaterion.</p></li></ul><p><strong>Returns</strong></p><p>The following vector: <code>[q1; q2; q3]</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L501-L515">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{AbstractArray{T,1} where T,ReferenceFrameRotations.Quaternion}" href="#Base.:*-Tuple{AbstractArray{T,1} where T,ReferenceFrameRotations.Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function *(v::AbstractVector, q::Quaternion)</code></pre><p>Compute the multiplication <code>v*q</code> in which <code>v</code> is a quaternion with real part <code>0</code> and vectorial/imaginary part <code>v</code>.</p><p><strong>Args</strong></p><ul><li><p><code>v</code>: Imaginary part of the quaternion that is the first operand of the    multiplication.</p></li><li><p><code>q</code>: Second operand of the multiplication.</p></li></ul><p><strong>Returns</strong></p><p>The quaternion <code>v*q</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L203-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{Number,ReferenceFrameRotations.Quaternion}" href="#Base.:*-Tuple{Number,ReferenceFrameRotations.Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function *(λ::Number, q::Quaternion{T2})</code></pre><p>Multiply the quaternion <code>q</code> by the scalar <code>λ</code>.</p><p><strong>Args</strong></p><ul><li><p><code>λ</code>: Scalar.</p></li><li><p><code>q</code>: Quaternion.</p></li></ul><p><strong>Returns</strong></p><p>The quaternion <code>λ*q</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L143-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{ReferenceFrameRotations.Quaternion,AbstractArray{T,1} where T}" href="#Base.:*-Tuple{ReferenceFrameRotations.Quaternion,AbstractArray{T,1} where T}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function *(q::Quaternion, v::AbstractVector)</code></pre><p>Compute the multiplication <code>q*v</code> in which <code>v</code> is a quaternion with real part <code>0</code> and vectorial/imaginary part <code>v</code>.</p><p><strong>Args</strong></p><ul><li><p><code>q</code>: First operand of the multiplication.</p></li><li><p><code>v</code>: Imaginary part of the quaternion that is the second operand of the    multiplication.</p></li></ul><p><strong>Returns</strong></p><p>The quaternion <code>q*v</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L227-L243">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{ReferenceFrameRotations.Quaternion,Number}" href="#Base.:*-Tuple{ReferenceFrameRotations.Quaternion,Number}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function *(q::Quaternion, λ::Number)</code></pre><p>Multiply the quaternion <code>q</code> by the scalar <code>λ</code>.</p><p><strong>Args</strong></p><ul><li><p><code>q</code>: Quaternion.</p></li><li><p><code>λ</code>: Scalar.</p></li></ul><p><strong>Returns</strong></p><p>The quaternion <code>q*λ</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L162-L176">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{ReferenceFrameRotations.Quaternion,ReferenceFrameRotations.Quaternion}" href="#Base.:*-Tuple{ReferenceFrameRotations.Quaternion,ReferenceFrameRotations.Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function *(q1::Quaternion, q2::Quaternion)</code></pre><p>Compute the multiplication <code>q1*q2</code>.</p><p><strong>Args</strong></p><ul><li><p><code>q1</code>: First operand of the multiplication.</p></li><li><p><code>q2</code>: Second operand of the multiplication.</p></li></ul><p><strong>Returns</strong></p><p>The quaternion <code>q1*q2</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L181-L195">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{ReferenceFrameRotations.Quaternion,ReferenceFrameRotations.Quaternion}" href="#Base.:+-Tuple{ReferenceFrameRotations.Quaternion,ReferenceFrameRotations.Quaternion}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function +(qa::Quaternion, qb::Quaternion)</code></pre><p>Sum the quaternion <code>qa</code> with the quaternion <code>qb</code>.</p><p><strong>Args</strong></p><ul><li><p><code>qa</code>: First operand of the sum.</p></li><li><p><code>qb</code>: Second operand of the sum.</p></li></ul><p><strong>Returns</strong></p><p>The quaternion <code>qa + qb</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L99-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:--Tuple{ReferenceFrameRotations.Quaternion,ReferenceFrameRotations.Quaternion}" href="#Base.:--Tuple{ReferenceFrameRotations.Quaternion,ReferenceFrameRotations.Quaternion}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function -(qa::Quaternion, qb::Quaternion)</code></pre><p>Subtract quaternion <code>qb</code> from quaternion <code>qa</code>.</p><p><strong>Args</strong></p><ul><li><p><code>qa</code>: First operand of the subtraction.</p></li><li><p><code>qb</code>: Second operand of the subtraction.</p></li></ul><p><strong>Returns</strong></p><p>The quaternion <code>qa - qb</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L121-L135">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:/-Tuple{Number,ReferenceFrameRotations.Quaternion}" href="#Base.:/-Tuple{Number,ReferenceFrameRotations.Quaternion}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function /(λ::Number, q::Quaternion)</code></pre><p>Compute the division <code>λ/q</code>.</p><p><strong>Args</strong></p><ul><li><p><code>λ</code>: First operand of the division (scalar).</p></li><li><p><code>q</code>: Second operand of the division (quaternion).</p></li></ul><p><strong>Returns</strong></p><p>The quaternion <code>λ/q</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L254-L268">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:/-Union{Tuple{ReferenceFrameRotations.Quaternion{T1},T2}, Tuple{T1}, Tuple{T2}} where T1&lt;:Real where T2&lt;:Real" href="#Base.:/-Union{Tuple{ReferenceFrameRotations.Quaternion{T1},T2}, Tuple{T1}, Tuple{T2}} where T1&lt;:Real where T2&lt;:Real"><code>Base.:/</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function /(q::Quaternion{T1}, λ::T1) where T1&lt;:Real where T2&lt;:Real</code></pre><p>Compute the division <code>q/λ</code>.</p><p><strong>Args</strong></p><ul><li><p><code>q</code>: First operand of the division (quaternion).</p></li><li><p><code>λ</code>: Second operand of the division (scalar).</p></li></ul><p><strong>Returns</strong></p><p>The quaternion <code>q/λ</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L275-L289">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.norm-Tuple{ReferenceFrameRotations.Quaternion}" href="#Base.LinAlg.norm-Tuple{ReferenceFrameRotations.Quaternion}"><code>Base.LinAlg.norm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function norm(q::Quaternion)</code></pre><p>Compute the Euclidean norm of the quaternion <code>q</code>.</p><p><strong>Args</strong></p><ul><li><p><code>q</code>: Quaternion.</p></li></ul><p><strong>Returns</strong></p><p>The Euclidean norm of <code>q</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L465-L478">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.conj-Tuple{ReferenceFrameRotations.Quaternion}" href="#Base.conj-Tuple{ReferenceFrameRotations.Quaternion}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function conj(q::Quaternion{T}) where T&lt;:Real</code></pre><p>Compute the complex conjugate of the quaternion <code>q</code>, which is:</p><pre><code class="language-none">q0 - q1.i - q2.j - q3.k</code></pre><p><strong>Args</strong></p><ul><li><p><code>q</code>: Quaternion.</p></li></ul><p><strong>Returns</strong></p><p>The complex conjugate of the quaternion <code>q</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L319-L334">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy-Union{Tuple{ReferenceFrameRotations.Quaternion{T}}, Tuple{T}} where T&lt;:Real" href="#Base.copy-Union{Tuple{ReferenceFrameRotations.Quaternion{T}}, Tuple{T}} where T&lt;:Real"><code>Base.copy</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function copy(q::Quaternion{T}) where T&lt;:Real</code></pre><p>Create a copy of the quaternion <code>q</code>.</p><p><strong>Args</strong></p><ul><li><p><code>q</code>: Quaternion that will be copied.</p></li></ul><p><strong>Returns</strong></p><p>The copy of the quaternion.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L340-L353">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eye-Union{Tuple{ReferenceFrameRotations.Quaternion{T}}, Tuple{T}} where T&lt;:Real" href="#Base.eye-Union{Tuple{ReferenceFrameRotations.Quaternion{T}}, Tuple{T}} where T&lt;:Real"><code>Base.eye</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function eye(q::Quaternion{T}) where T&lt;:Real</code></pre><p>Create the identity quaternion (<code>1 + 0.i + 0.j + 0.k</code>) with the same type of another quaternion <code>q</code>.</p><p><strong>Args</strong></p><ul><li><p><code>q</code>: A quaternion of type <code>T</code>.</p></li></ul><p><strong>Returns</strong></p><p>The identity quaternion of type <code>T</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q1 = Quaternion{Float32}(cosd(45/2),sind(45/2),0.,0.);

julia&gt; q2 = eye(q1)
Quaternion{Float32}:
  + 1.0 + 0.0.i + 0.0.j + 0.0.k</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L393-L417">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eye-Union{Tuple{T}, Tuple{Type{ReferenceFrameRotations.Quaternion{T}}}} where T&lt;:Real" href="#Base.eye-Union{Tuple{T}, Tuple{Type{ReferenceFrameRotations.Quaternion{T}}}} where T&lt;:Real"><code>Base.eye</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function eye(::Type{Quaternion{T}}) where T&lt;:Real</code></pre><p>Create the identity quaternion (<code>1 + 0.i + 0.j + 0.k</code>) of type <code>T</code>.</p><p><strong>Args</strong></p><ul><li><p><code>Quaternion{T}</code>, where <code>T</code> is the desired type. If <code>T</code> is omitted, then it falls back to <code>Float64</code>.</p></li></ul><p><strong>Returns</strong></p><p>The identity quaternion of type <code>T</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; eye(Quaternion{Float32})
Quaternion{Float32}:
  + 1.0 + 0.0.i + 0.0.j + 0.0.k

julia&gt; eye(Quaternion{Float64})
Quaternion{Float64}:
  + 1.0 + 0.0.i + 0.0.j + 0.0.k</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L358-L384">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Union{Tuple{ReferenceFrameRotations.Quaternion{T},Colon}, Tuple{T}} where T&lt;:Real" href="#Base.getindex-Union{Tuple{ReferenceFrameRotations.Quaternion{T},Colon}, Tuple{T}} where T&lt;:Real"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function getindex(q::Quaternion{T}, ::Colon) where T&lt;:Real</code></pre><p>Transform the quaternion into a 4x1 vector of type <code>T</code>.</p><p><strong>Args</strong></p><ul><li><p><code>q</code>: Quaternion.</p></li></ul><p><strong>Returns</strong></p><p>A 4x1 vector of type <code>T</code> with the elements of the quaternion.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L297-L310">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.imag-Tuple{ReferenceFrameRotations.Quaternion}" href="#Base.imag-Tuple{ReferenceFrameRotations.Quaternion}"><code>Base.imag</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function imag(q::Quaternion{T}) where T&lt;:Real</code></pre><p>Return the vectorial or imaginary part of the quaternion represented by a 3x1 vector.</p><p><strong>Args</strong></p><ul><li><p><code>q</code>: Quaterion.</p></li></ul><p><strong>Returns</strong></p><p>The following vector: <code>[q1; q2; q3]</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L422-L436">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{ReferenceFrameRotations.Quaternion}" href="#Base.inv-Tuple{ReferenceFrameRotations.Quaternion}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function inv(q::Quaternion)</code></pre><p>Compute the inverse of the quaternion <code>q</code>:</p><pre><code class="language-none">conj(q)
-------
norm(q)</code></pre><p><strong>Args</strong></p><ul><li><p><code>q</code>: Quaternion.</p></li></ul><p><strong>Returns</strong></p><p>Inverse of the quaternion <code>q</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L441-L458">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.real-Tuple{ReferenceFrameRotations.Quaternion}" href="#Base.real-Tuple{ReferenceFrameRotations.Quaternion}"><code>Base.real</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function real(q::Quaternion)</code></pre><p>Return the real part of the quaternion <code>q</code>.</p><p><strong>Args</strong></p><ul><li><p><code>q</code>: Quaternion.</p></li></ul><p><strong>Returns</strong></p><p>The scalar <code>q0</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L483-L496">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show-Union{Tuple{IO,ReferenceFrameRotations.Quaternion{T}}, Tuple{T}} where T&lt;:Real" href="#Base.show-Union{Tuple{IO,ReferenceFrameRotations.Quaternion{T}}, Tuple{T}} where T&lt;:Real"><code>Base.show</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function show(io::IO, q::Quaternion{T}) where T&lt;:Real</code></pre><p>Print the quaternion <code>q</code> to the stream <code>io</code>.</p><p><strong>Args</strong></p><ul><li><p><code>io</code>: Stream that will be used to print the quaternion.</p></li><li><p><code>q</code>: The quaternion that will be printed.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L588-L598">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.zeros-Union{Tuple{ReferenceFrameRotations.Quaternion{T}}, Tuple{T}} where T&lt;:Real" href="#Base.zeros-Union{Tuple{ReferenceFrameRotations.Quaternion{T}}, Tuple{T}} where T&lt;:Real"><code>Base.zeros</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function zeros(q::Quaternion{T}) where T&lt;:Real</code></pre><p>Create the null quaternion (<code>0 + 0.i + 0.j + 0.k</code>) with the same type of another quaternion <code>q</code>.</p><p><strong>Args</strong></p><ul><li><p><code>q</code>: A quaternion of type <code>T</code>.</p></li></ul><p><strong>Returns</strong></p><p>The null quaternion of type <code>T</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q1 = Quaternion{Float32}(cosd(45/2),sind(45/2),0,0);

julia&gt; zeros(q1)
Quaternion{Float32}:
  + 0.0 + 0.0.i + 0.0.j + 0.0.k</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L555-L579">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.zeros-Union{Tuple{T}, Tuple{Type{ReferenceFrameRotations.Quaternion{T}}}} where T&lt;:Real" href="#Base.zeros-Union{Tuple{T}, Tuple{Type{ReferenceFrameRotations.Quaternion{T}}}} where T&lt;:Real"><code>Base.zeros</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">@inline function zeros(::Type{Quaternion{T}}) where T&lt;:Real</code></pre><p>Create the null quaternion (<code>0 + 0.i + 0.j + 0.k</code>) of type <code>T</code>.</p><p><strong>Args</strong></p><ul><li><p><code>Quaternion{T}</code>, where <code>T</code> is the desired type. If <code>T</code> is omitted, then it falls back to <code>Float64</code>.</p></li></ul><p><strong>Returns</strong></p><p>The null quaternion of type <code>T</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; zeros(Quaternion{Float32})
Quaternion{Float32}:
  + 0.0 + 0.0.i + 0.0.j + 0.0.k

julia&gt; zeros(Quaternion)
Quaternion{Float64}:
  + 0.0 + 0.0.i + 0.0.j + 0.0.k</code></pre></div><a class="source-link" target="_blank" href="https://github.com/SatelliteToolbox/ReferenceFrameRotations.jl/blob/5cd5dfa361a2e12ed3c1fa921357c19668cebcfa/src/quaternion.jl#L520-L546">source</a></section><footer><hr/><a class="previous" href="../../man/inv_rotations/"><span class="direction">Previous</span><span class="title">Inverting rotations</span></a></footer></article></body></html>
