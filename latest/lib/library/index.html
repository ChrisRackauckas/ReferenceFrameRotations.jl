<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Reference Frame Rotations</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Reference Frame Rotations logo"/></a><h1>Reference Frame Rotations</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../man/dcm/">Direction Cosine Matrices</a></li><li><a class="toctext" href="../../man/euler_angle_axis/">Euler Angle and Axis</a></li><li><a class="toctext" href="../../man/euler_angles/">Euler Angles</a></li><li><a class="toctext" href="../../man/quaternions/">Quaternions</a></li><li><a class="toctext" href="../../man/conversions/">Conversions</a></li><li><a class="toctext" href="../../man/kinematics/">Kinematics</a></li><li><a class="toctext" href="../../man/composing_rotations/">Composing rotations</a></li><li><a class="toctext" href="../../man/inv_rotations/">Inverting rotations</a></li><li class="current"><a class="toctext" href>Library</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Library</a></li></ul><a class="edit-page" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/master/docs/src/lib/library.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Library</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Library-1" href="#Library-1">Library</a></h1><p>Documentation for <code>ReferenceFrameRotations.jl</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.DCM" href="#ReferenceFrameRotations.DCM"><code>ReferenceFrameRotations.DCM</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The Direction Cosine Matrix of type <code>T</code> is a <code>SMatrix{3,3,T,9}</code>, which is a 3x3 static matrix of type <code>T</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/ReferenceFrameRotations.jl#L19-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.EulerAngleAxis" href="#ReferenceFrameRotations.EulerAngleAxis"><code>ReferenceFrameRotations.EulerAngleAxis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct EulerAngleAxis{T}</code></pre><p>The definition of Euler Angle and Axis to represent a 3D rotation.</p><p><strong>Fields</strong></p><ul><li><code>a</code>: The Euler angle [rad].</li><li><code>v</code>: The unitary vector aligned with the Euler axis.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-none">function EulerAngleAxis(a::T1, v::AbstractVector{T2}) where {T1,T2}</code></pre><p>Create an Euler Angle and Axis representation structure with angle <code>a</code> [rad] and vector <code>v</code>. Notice that the vector <code>v</code> will not be normalized. The type of the returned structure will be selected according to the input types.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/ReferenceFrameRotations.jl#L45-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.EulerAngles" href="#ReferenceFrameRotations.EulerAngles"><code>ReferenceFrameRotations.EulerAngles</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct EulerAngles{T}</code></pre><p>The definition of Euler Angles, which is composed of three angles <code>a1</code>, <code>a2</code>, and <code>a3</code> together with a rotation sequence <code>rot_seq</code>. The latter is provided by a symbol with three characters, each one indicating the rotation axis of the corresponding angle (for example, <code>:ZYX</code>). The valid values for <code>rot_seq</code> are:</p><ul><li><code>:XYX</code>, <code>:XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>ZYZ</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/ReferenceFrameRotations.jl#L26-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion" href="#ReferenceFrameRotations.Quaternion"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>struct Quaternion{T}</strong></p><p>The definition of the quaternion. It has four values of type <code>T</code>. The quaternion representation is:</p><pre><code class="language-none">q0 + q1.i + q2.j + q3.k</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/ReferenceFrameRotations.jl#L77-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion-Tuple{AbstractArray{T,1} where T}" href="#ReferenceFrameRotations.Quaternion-Tuple{AbstractArray{T,1} where T}"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function Quaternion(v::AbstractVector)</code></pre><p>If the vector <code>v</code> has 3 components, then create a quaternion in which the real part is <code>0</code> and the vectorial or imaginary part has the same components of the vector <code>v</code>. In other words:</p><pre><code class="language-none">q = 0 + v[1].i + v[2].j + v[3].k</code></pre><p>Otherwise, if the vector <code>v</code> has 4 components, then create a quaternion in which the elements match those of the input vector:</p><pre><code class="language-none">q = v[1] + v[2].i + v[3].j + v[4].k</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L31-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion-Tuple{Number,AbstractArray{T,1} where T}" href="#ReferenceFrameRotations.Quaternion-Tuple{Number,AbstractArray{T,1} where T}"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function Quaternion(r::Number, v::AbstractVector)</code></pre><p>Create a quaternion with real part <code>r</code> and vectorial or imaginary part <code>v</code>:</p><pre><code class="language-none">r + v[1].i + v[2].j + v[3].k</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L59-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T0}, Tuple{T0,T1,T2,T3}} where T3 where T2 where T1 where T0" href="#ReferenceFrameRotations.Quaternion-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T0}, Tuple{T0,T1,T2,T3}} where T3 where T2 where T1 where T0"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function Quaternion(q0::T0, q1::T1, q2::T2, q3::T3) where {T0,T1,T2,T3}</code></pre><p>Create the following quaternion:</p><pre><code class="language-none">q0 + q1.i + q2.j + q3.k</code></pre><p>in which:</p><ul><li><code>q0</code> is the real part of the quaternion.</li><li><code>q1</code> is the X component of the quaternion vectorial part.</li><li><code>q2</code> is the Y component of the quaternion vectorial part.</li><li><code>q3</code> is the Z component of the quaternion vectorial part.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L11-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion-Union{Tuple{T}, Tuple{UniformScaling,Quaternion{T}}} where T" href="#ReferenceFrameRotations.Quaternion-Union{Tuple{T}, Tuple{UniformScaling,Quaternion{T}}} where T"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function Quaternion(::UniformScaling,::Quaternion{T}) where T</code></pre><p>Create an identity quaternion of type <code>T</code>:</p><pre><code class="language-none">T(1) + T(0).i + T(0).j + T(0).k</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L79-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion-Union{Tuple{UniformScaling{T}}, Tuple{T}} where T" href="#ReferenceFrameRotations.Quaternion-Union{Tuple{UniformScaling{T}}, Tuple{T}} where T"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function Quaternion(u::UniformScaling{T}) where T
function Quaternion{T}(u::UniformScaling) where T</code></pre><p>Create the quaternion <code>u.λ + 0.i + 0.j + 0.k</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L69-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{EulerAngleAxis}" href="#Base.inv-Tuple{EulerAngleAxis}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function inv(ea::EulerAngleAxis)</code></pre><p>Compute the inverse rotation of <code>ea</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/euler_angle_axis.jl#L53-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{EulerAngles}" href="#Base.inv-Tuple{EulerAngles}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function inv(Θ::EulerAngles)</code></pre><p>Return the Euler angles that represent the inverse rotation of <code>Θ</code>. Notice that the rotation sequence of the result will be the inverse of the input. Hence, if the input rotation sequence is, for example, <code>:XYZ</code>, then the result will be represented using <code>:ZYX</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/euler_angles.jl#L30-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{Quaternion}" href="#Base.inv-Tuple{Quaternion}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function inv(q::Quaternion)</code></pre><p>Compute the inverse of the quaternion <code>q</code>:</p><pre><code class="language-none">conj(q)
-------
  |q|²</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L311-L320">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{Quaternion}" href="#LinearAlgebra.norm-Tuple{Quaternion}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function norm(q::Quaternion)</code></pre><p>Compute the Euclidean norm of the quaternion <code>q</code>:</p><pre><code class="language-none">sqrt(q0² + q1² + q2² + q3²)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L327-L334">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_dcm" href="#ReferenceFrameRotations.angle_to_dcm"><code>ReferenceFrameRotations.angle_to_dcm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">function angle_to_dcm(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX)</code></pre><p>Convert the Euler angles <code>θ₁</code>, <code>θ₂</code>, and <code>θ₃</code> [rad] with the rotation sequence <code>rot_seq</code> to a direction cosine matrix.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Remarks</strong></p><p>This function assigns <code>dcm = A3 * A2 * A1</code> in which <code>Ai</code> is the DCM related with the <em>i</em>-th rotation, <code>i Є [1,2,3]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">dcm = angle_to_dcm(pi/2, pi/3, pi/4, :ZYX)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/euler_angles.jl#L68-L93">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_dcm-Tuple{EulerAngles}" href="#ReferenceFrameRotations.angle_to_dcm-Tuple{EulerAngles}"><code>ReferenceFrameRotations.angle_to_dcm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function angle_to_dcm(Θ::EulerAngles)</code></pre><p>Convert the Euler angles <code>Θ</code> (see <code>EulerAngles</code>) to a direction cosine matrix.</p><p><strong>Returns</strong></p><p>The direction cosine matrix.</p><p><strong>Remarks</strong></p><p>This function assigns <code>dcm = A3 * A2 * A1</code> in which <code>Ai</code> is the DCM related with the <em>i</em>-th rotation, <code>i Є [1,2,3]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; angle_to_dcm(EulerAngles(pi/2, pi/3, pi/4, :ZYX))
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/euler_angles.jl#L165-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_quat" href="#ReferenceFrameRotations.angle_to_quat"><code>ReferenceFrameRotations.angle_to_quat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">function angle_to_quat(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX)</code></pre><p>Convert the Euler angles <code>θ₁</code>, <code>θ₂</code>, and <code>θ₃</code> [rad] with the rotation sequence <code>rot_seq</code> to a quaternion.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Remarks</strong></p><p>This function assigns <code>q = q1 * q2 * q3</code> in which <code>qi</code> is the quaternion related with the <em>i</em>-th rotation, <code>i Є [1,2,3]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; angle_to_quat(pi/2, pi/3, pi/4, :ZYX)
Quaternion{Float64}:
  + 0.7010573846499779 - 0.09229595564125714.i + 0.5609855267969309.j + 0.43045933457687935.k</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/euler_angles.jl#L220-L243">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_quat-Tuple{EulerAngles}" href="#ReferenceFrameRotations.angle_to_quat-Tuple{EulerAngles}"><code>ReferenceFrameRotations.angle_to_quat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function angle_to_quat(eulerang::EulerAngles)</code></pre><p>Convert the Euler angles <code>eulerang</code> (see <code>EulerAngles</code>) to a quaternion.</p><p><strong>Remarks</strong></p><p>This function assigns <code>q = q1 * q2 * q3</code> in which <code>qi</code> is the quaternion related with the <em>i</em>-th rotation, <code>i Є [1,2,3]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; angle_to_quat(pi/2, pi/3, pi/4, :ZYX)
Quaternion{Float64}:
  + 0.7010573846499779 - 0.09229595564125714.i + 0.5609855267969309.j + 0.43045933457687935.k</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/euler_angles.jl#L364-L382">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_rot-Tuple{EulerAngles}" href="#ReferenceFrameRotations.angle_to_rot-Tuple{EulerAngles}"><code>ReferenceFrameRotations.angle_to_rot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline angle_to_rot([T,] Θ::EulerAngles)</code></pre><p>Convert the Euler angles <code>Θ</code> (see <code>EulerAngles</code>) to a rotation description of type <code>T</code>, which can be <code>DCM</code> or <code>Quaternion</code>. If the type <code>T</code> is not specified, then it defaults to <code>DCM</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dcm = angle_to_rot(EulerAngles(pi/2, pi/3, pi/4, :ZYX))
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553

julia&gt; q   = angle_to_rot(Quaternion,EulerAngles(pi/2, pi/3, pi/4, :ZYX))
Quaternion{Float64}:
  + 0.7010573846499779 - 0.09229595564125714.i + 0.5609855267969309.j +
  0.43045933457687935.k</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/euler_angles.jl#L455-L477">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_rot-Tuple{Number,Number,Number,Symbol}" href="#ReferenceFrameRotations.angle_to_rot-Tuple{Number,Number,Number,Symbol}"><code>ReferenceFrameRotations.angle_to_rot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline angle_to_rot([T,] θx::Number, θy::Number, θz::Number, rot_seq::Symbol)</code></pre><p>Convert the Euler angles <code>Θx</code>, <code>Θy</code>, and <code>Θz</code> [rad] with the rotation sequence <code>rot_seq</code> to a rotation description of type <code>T</code>, which can be <code>DCM</code> or <code>Quaternion</code>. If the type <code>T</code> is not specified, then it defaults to <code>DCM</code>.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dcm = angle_to_rot(pi/2, pi/3, pi/4, :ZYX)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553

julia&gt; q   = angle_to_rot(Quaternion,pi/2, pi/3, pi/4, :ZYX)
Quaternion{Float64}:
  + 0.7010573846499779 - 0.09229595564125714.i + 0.5609855267969309.j + 0.43045933457687935.k</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/euler_angles.jl#L418-L443">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angleaxis_to_quat-Tuple{EulerAngleAxis}" href="#ReferenceFrameRotations.angleaxis_to_quat-Tuple{EulerAngleAxis}"><code>ReferenceFrameRotations.angleaxis_to_quat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function angleaxis_to_quat(angleaxis::EulerAngleAxis)</code></pre><p>Convert a Euler angle and Euler axis <code>angleaxis</code> (see <code>EulerAngleAxis</code>) to a quaternion.</p><p><strong>Remarks</strong></p><p>It is expected that the vector <code>angleaxis.v</code> is unitary. However, no verification is performed inside the function. The user must handle this situation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1;1;1];

julia&gt; v /= norm(v);

julia&gt; angleaxis_to_quat(EulerAngleAxis(pi/2,v))
Quaternion{Float64}:
  + 0.7071067811865476 + 0.408248290463863.i + 0.408248290463863.j + 0.408248290463863.k</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/euler_angle_axis.jl#L100-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angleaxis_to_quat-Tuple{Number,AbstractArray{T,1} where T}" href="#ReferenceFrameRotations.angleaxis_to_quat-Tuple{Number,AbstractArray{T,1} where T}"><code>ReferenceFrameRotations.angleaxis_to_quat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function angleaxis_to_quat(a::Number, v::AbstractVector)</code></pre><p>Convert the Euler angle <code>a</code> [rad] and Euler axis <code>v</code>, which must be a unit vector, to a quaternion.</p><p><strong>Remarks</strong></p><p>It is expected that the vector <code>v</code> is unitary. However, no verification is performed inside the function. The user must handle this situation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1;1;1];

julia&gt; v /= norm(v);

julia&gt; angleaxis_to_quat(pi/2,v)
Quaternion{Float64}:
  + 0.7071067811865476 + 0.408248290463863.i + 0.408248290463863.j + 0.408248290463863.k</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/euler_angle_axis.jl#L68-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.compose_rotation-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,9} where T}" href="#ReferenceFrameRotations.compose_rotation-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,9} where T}"><code>ReferenceFrameRotations.compose_rotation</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function compose_rotation(R1, [, R2, R3, R4, R5, ...])</code></pre><p>Compute a composed rotation using the rotations <code>R1</code>, <code>R2</code>, <code>R3</code>, <code>R4</code>, ..., in the following order:</p><pre><code class="language-none"> First rotation
 |
 |
R1 =&gt; R2 =&gt; R3 =&gt; R4 =&gt; ...
       |
       |
       Second rotation</code></pre><p>The rotations can be described by Direction Cosine Matrices or Quaternions. Notice, however, that all rotations <strong>must be</strong> of the same type (DCM or quaternion).</p><p>The output will have the same type as the inputs (DCM or quaternion).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; D1 = angle_to_dcm(+pi/3,+pi/4,+pi/5,:ZYX);

julia&gt; D2 = angle_to_dcm(-pi/5,-pi/4,-pi/3,:XYZ);

julia&gt; compose_rotation(D1,D2)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 1.0          0.0          5.55112e-17
 0.0          1.0          5.55112e-17
 5.55112e-17  5.55112e-17  1.0

julia&gt; q1 = angle_to_quat(+pi/3,+pi/4,+pi/5,:ZYX);

julia&gt; q2 = angle_to_quat(-pi/5,-pi/4,-pi/3,:XYZ);

julia&gt; compose_rotation(q1,q2)
Quaternion{Float64}:
  + 1.0 + 0.0.i + 2.0816681711721685e-17.j + 5.551115123125783e-17.k</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/compose_rotations.jl#L7-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.create_rotation_matrix" href="#ReferenceFrameRotations.create_rotation_matrix"><code>ReferenceFrameRotations.create_rotation_matrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">function create_rotation_matrix(angle::Number, axis::Symbol = :X)</code></pre><p>Compute a rotation matrix that rotates a coordinate frame about the axis <code>axis</code> by the angle <code>angle</code>. The <code>axis</code> must be one of the following symbols: <code>:X</code>, <code>:Y</code>, or <code>:Z</code>.</p><p><strong>Example</strong></p><pre><code class="language-jldocstest">julia&gt; create_rotation_matrix(pi/2, :X)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 1.0   0.0          0.0
 0.0   6.12323e-17  1.0
 0.0  -1.0          6.12323e-17</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/DCM.jl#L12-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.dcm_to_angle-Union{Tuple{SArray{Tuple{3,3},T,2,9}}, Tuple{T}, Tuple{SArray{Tuple{3,3},T,2,9},Symbol}} where T&lt;:Number" href="#ReferenceFrameRotations.dcm_to_angle-Union{Tuple{SArray{Tuple{3,3},T,2,9}}, Tuple{T}, Tuple{SArray{Tuple{3,3},T,2,9},Symbol}} where T&lt;:Number"><code>ReferenceFrameRotations.dcm_to_angle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function dcm_to_angle(dcm::DCM, rot_seq::Symbol=:ZYX)</code></pre><p>Convert the DCM <code>dcm</code> to Euler Angles (see <code>EulerAngles</code>) given a rotation sequence <code>rot_seq</code>.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; D = DCM([1. 0. 0.; 0. 0. -1; 0. -1 0.]);

julia&gt; dcm_to_angle(D,:XYZ)
ReferenceFrameRotations.EulerAngles{Float64}(1.5707963267948966, 0.0, -0.0, :XYZ)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/DCM.jl#L65-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.dcm_to_quat-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,9} where T}" href="#ReferenceFrameRotations.dcm_to_quat-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,9} where T}"><code>ReferenceFrameRotations.dcm_to_quat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function dcm_to_quat(dcm::DCM)</code></pre><p>Convert the DCM <code>dcm</code> to a quaternion. The type of the quaternion will be automatically selected by the constructor <code>Quaternion</code> to avoid <code>InexactError</code>.</p><p><strong>Remarks</strong></p><p>By convention, the real part of the quaternion will always be positive. Moreover, the function does not check if <code>dcm</code> is a valid direction cosine matrix. This must be handle by the user.</p><p>This algorithm was obtained from:</p><pre><code class="language-none">http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/</code></pre><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dcm = angle_to_dcm(pi/2,0.0,0.0,:XYZ);

julia&gt; q   = dcm_to_quat(dcm)
Quaternion{Float64}:
  + 0.7071067811865476 + 0.7071067811865475.i + 0.0.j + 0.0.k</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/DCM.jl#L226-L252">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.ddcm-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,9} where T,AbstractArray}" href="#ReferenceFrameRotations.ddcm-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,9} where T,AbstractArray}"><code>ReferenceFrameRotations.ddcm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function ddcm(Dba::DCM, wba_b::AbstractArray)</code></pre><p>Compute the time-derivative of the DCM <code>dcm</code> that rotates a reference frame <code>a</code> into alignment to the reference frame <code>b</code> in which the angular velocity of <code>b</code> with respect to <code>a</code>, and represented in <code>b</code>, is <code>wba_b</code>.</p><p><strong>Returns</strong></p><p>The time-derivative of the DCM <code>Dba</code> (3x3 matrix of type <code>SMatrix{3,3}</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; D = DCM(Matrix{Float64}(I,3,3));

julia&gt; ddcm(D,[1;0;0])
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 0.0   0.0  0.0
 0.0   0.0  1.0
 0.0  -1.0  0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/DCM.jl#L314-L337">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.dquat-Tuple{Quaternion,AbstractArray{T,1} where T}" href="#ReferenceFrameRotations.dquat-Tuple{Quaternion,AbstractArray{T,1} where T}"><code>ReferenceFrameRotations.dquat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function dquat(qba::Quaternion, wba_b::AbstractVector)</code></pre><p>Compute the time-derivative of the quaternion <code>qba</code> that rotates a reference frame <code>a</code> into alignment to the reference frame <code>b</code> in which the angular velocity of <code>b</code> with respect to <code>a</code>, and represented in <code>b</code>, is <code>wba_b</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Quaternion(1.0I);

julia&gt; dquat(q,[1;0;0])
Quaternion{Float64}:
  + 0.0 + 0.5.i + 0.0.j + 0.0.k</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L542-L559">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.inv_rotation-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,9} where T}" href="#ReferenceFrameRotations.inv_rotation-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,9} where T}"><code>ReferenceFrameRotations.inv_rotation</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function inv_rotation(R)</code></pre><p>Compute the inverse rotation of <code>R</code>, which can be a Direction Cosine Matrix or Quaternion.</p><p>The output will have the same type as <code>R</code> (DCM or quaternion).</p><p><strong>Remarks</strong></p><p>If <code>R</code> is a DCM, than its transpose is computed instead of its inverse to reduce the computational burden. The both are equal if the DCM has unit norm. This must be verified by the used.</p><p>If <code>R</code> is a quaternion, than its conjugate is computed instead of its inverse to reduce the computational burden. The both are equal if the quaternion has unit norm. This must be verified by the used.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; D = angle_to_dcm(+pi/3,+pi/4,+pi/5,:ZYX);

julia&gt; inv_rotation(D)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  0.353553  -0.492816  0.795068
  0.612372   0.764452  0.201527
 -0.707107   0.415627  0.572061

julia&gt; q = angle_to_quat(+pi/3,+pi/4,+pi/5,:ZYX);

julia&gt; inv_rotation(q)
Quaternion{Float64}:
  + 0.8200711519756747 - 0.06526868310243991.i - 0.45794027732580056.j - 0.336918398289752.k</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/inv_rotations.jl#L7-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.quat_to_angle" href="#ReferenceFrameRotations.quat_to_angle"><code>ReferenceFrameRotations.quat_to_angle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">function quat_to_angle(q::Quaternion, rot_seq::Symbol = :ZYX)</code></pre><p>Convert the quaternion <code>q</code> to Euler Angles (see <code>EulerAngles</code>) given a rotation sequence <code>rot_seq</code>.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Quaternion(cosd(45/2), sind(45/2), 0, 0);

julia&gt; quat_to_angle(q,:XYZ)
EulerAngles{Float64}(0.7853981633974484, 0.0, -0.0, :XYZ)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L506-L525">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.quat_to_angleaxis-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#ReferenceFrameRotations.quat_to_angleaxis-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>ReferenceFrameRotations.quat_to_angleaxis</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function quat_to_angleaxis(q::Quaternion{T}) where T</code></pre><p>Convert the quaternion <code>q</code> to a Euler angle and axis representation (see <code>EulerAngleAxis</code>).</p><p><strong>Remarks</strong></p><p>This function will not fail if the quaternion norm is not 1. However, the meaning of the results will not be defined, because the input quaternion does not represent a 3D rotation. The user must handle such situations.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Quaternion(cosd(45/2), sind(45/2), 0, 0);

julia&gt; quat_to_angleaxis(q)
EulerAngleAxis{Float64}(0.7853981633974484, [1.0, 0.0, 0.0])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L471-L492">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.quat_to_dcm-Tuple{Quaternion}" href="#ReferenceFrameRotations.quat_to_dcm-Tuple{Quaternion}"><code>ReferenceFrameRotations.quat_to_dcm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function quat_to_dcm(q::Quaternion)</code></pre><p>Convert the quaternion <code>q</code> to a Direction Cosine Matrix (DCM).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Quaternion(cosd(45/2), sind(45/2), 0, 0);

julia&gt; quat_to_dcm(q)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 1.0   0.0       0.0
 0.0   0.707107  0.707107
 0.0  -0.707107  0.707107</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L438-L455">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.smallangle_to_dcm-Tuple{Number,Number,Number}" href="#ReferenceFrameRotations.smallangle_to_dcm-Tuple{Number,Number,Number}"><code>ReferenceFrameRotations.smallangle_to_dcm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function smallangle_to_dcm(θx::Number, θy::Number, θz::Number)</code></pre><p>Create a direction cosine matrix from three small rotations of angles <code>θx</code>, <code>θy</code>, and <code>θz</code> [rad] about the axes X, Y, and Z, respectively.</p><p><strong>Remarks</strong></p><p>No process of ortho-normalization is performed with the computed DCM.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; smallangle_to_dcm(+0.01, -0.01, +0.01)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  1.0    0.01  0.01
 -0.01   1.0   0.01
 -0.01  -0.01  1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/euler_angles.jl#L192-L212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.smallangle_to_quat-Tuple{Number,Number,Number}" href="#ReferenceFrameRotations.smallangle_to_quat-Tuple{Number,Number,Number}"><code>ReferenceFrameRotations.smallangle_to_quat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function smallangle_to_quat(θx::Number, θy::Number, θz::Number)</code></pre><p>Create a quaternion from three small rotations of angles <code>θx</code>, <code>θy</code>, and <code>θz</code> [rad] about the axes X, Y, and Z, respectively.</p><p><strong>Remarks</strong></p><p>The quaternion is normalized.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; smallangle_to_quat(+0.01, -0.01, +0.01)
Quaternion{Float64}:
  + 0.9999625021092433 + 0.004999812510546217.i - 0.004999812510546217.j + 0.004999812510546217.k</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/euler_angles.jl#L385-L403">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.smallangle_to_rot-Tuple{Number,Number,Number}" href="#ReferenceFrameRotations.smallangle_to_rot-Tuple{Number,Number,Number}"><code>ReferenceFrameRotations.smallangle_to_rot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function smallangle_to_rot([T,] θx::Number, θy::Number, θz::Number)</code></pre><p>Create a rotation description of type <code>T</code> from three small rotations of angles <code>θx</code>, <code>θy</code>, and <code>θz</code> [rad] about the axes X, Y, and Z, respectively.</p><p>The type <code>T</code> of the rotation description can be <code>DCM</code> or <code>Quaternion</code>. If the type <code>T</code> is not specified, then if defaults to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation description according to the type <code>T</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dcm = smallangle_to_rot(+0.01, -0.01, +0.01);

julia&gt; q   = smallangle_to_rot(Quaternion,+0.01, -0.01, +0.01);

julia&gt; dcm = smallangle_to_rot(+0.01, -0.01, +0.01)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  1.0    0.01  0.01
 -0.01   1.0   0.01
 -0.01  -0.01  1.0

julia&gt; q   = smallangle_to_rot(Quaternion,+0.01, -0.01, +0.01)
Quaternion{Float64}:
  + 0.9999625021092433 + 0.004999812510546217.i - 0.004999812510546217.j + 0.004999812510546217.k</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/euler_angles.jl#L486-L517">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.vect-Tuple{Quaternion}" href="#ReferenceFrameRotations.vect-Tuple{Quaternion}"><code>ReferenceFrameRotations.vect</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function vect(q::Quaternion)</code></pre><p>Return the vectorial or imaginary part of the quaternion <code>q</code> represented by a 3 × 1 vector of type <code>SVector{3}</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L345-L351">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{AbstractArray{T,1} where T,Quaternion}" href="#Base.:*-Tuple{AbstractArray{T,1} where T,Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function *(v::AbstractVector, q::Quaternion)
@inline function *(q::Quaternion, v::AbstractVector)</code></pre><p>Compute the multiplication <code>qv*q</code> or <code>q*qv</code> in which <code>qv</code> is a quaternion with real part <code>0</code> and vectorial/imaginary part <code>v</code> (Hamilton product).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L168-L175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{EulerAngles,EulerAngles}" href="#Base.:*-Tuple{EulerAngles,EulerAngles}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function *(Θ₂::EulerAngles, Θ₁::EulerAngles)</code></pre><p>Compute the composed rotation of <code>Θ₁ -&gt; Θ₂</code>. Notice that the rotation will be represented by Euler angles (see <code>EulerAngles</code>) with the same rotation sequence as <code>Θ₂</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/euler_angles.jl#L13-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{LinearAlgebra.UniformScaling,Quaternion}" href="#Base.:*-Tuple{LinearAlgebra.UniformScaling,Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function *(u::UniformScaling, q::Quaternion)
@inline function *(q::Quaternion, u::UniformScaling)</code></pre><p>Compute <code>qu*q</code> or <code>q*qu</code> (Hamilton product), in which <code>qu</code> is the scaled identity quaternion <code>qu = u.λ * I</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L188-L195">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{Number,Quaternion}" href="#Base.:*-Tuple{Number,Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function *(λ::Number, q::Quaternion)
@inline function *(q::Quaternion, λ::Number)</code></pre><p>Compute <code>λ*q</code> or <code>q*λ</code>, in which <code>λ</code> is a scalar.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L146-L152">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{Quaternion,Quaternion}" href="#Base.:*-Tuple{Quaternion,Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function *(q1::Quaternion, q2::Quaternion)</code></pre><p>Compute the quaternion multiplication <code>q1*q2</code> (Hamilton product).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L156-L161">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Union{Tuple{T2}, Tuple{T1}, Tuple{EulerAngleAxis{T1},EulerAngleAxis{T2}}} where T2 where T1" href="#Base.:*-Union{Tuple{T2}, Tuple{T1}, Tuple{EulerAngleAxis{T1},EulerAngleAxis{T2}}} where T2 where T1"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function *(ea₂::EulerAngleAxis{T1}, ea₁::EulerAngleAxis{T2}) where {T1,T2}</code></pre><p>Compute the composed rotation of <code>ea₁ -&gt; ea₂</code>. Notice that the rotation will be represented by a Euler angle and axis (see <code>EulerAngleAxis</code>). By convention, the output angle will always be in the range [0, 2π] [rad].</p><p>Notice that the vector representing the axis in <code>ea₁</code> and <code>ea₂</code> must be unitary. This function neither verifies this nor normalizes the vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/euler_angle_axis.jl#L11-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{LinearAlgebra.UniformScaling,Quaternion}" href="#Base.:+-Tuple{LinearAlgebra.UniformScaling,Quaternion}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function +(u::UniformScaling, q::Quaternion)
@inline function +(q::Quaternion, u::UniformScaling)</code></pre><p>Compute <code>qu + q</code> or <code>q + qu</code>, in which <code>qu</code> is the scaled identity quaternion <code>qu = u.λ * I</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L105-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{Quaternion,Quaternion}" href="#Base.:+-Tuple{Quaternion,Quaternion}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function +(qa::Quaternion, qb::Quaternion)</code></pre><p>Compute <code>qa + qb</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L96-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:--Tuple{LinearAlgebra.UniformScaling,Quaternion}" href="#Base.:--Tuple{LinearAlgebra.UniformScaling,Quaternion}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function -(u::UniformScaling, q::Quaternion)
@inline function -(q::Quaternion, u::UniformScaling)</code></pre><p>Compute <code>qu - q</code> or <code>q - qu</code>, in which <code>qu</code> is the scaled identity quaternion <code>qu = u.λ * I</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L130-L137">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:--Tuple{Quaternion,Quaternion}" href="#Base.:--Tuple{Quaternion,Quaternion}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function -(qa::Quaternion, qb::Quaternion)</code></pre><p>Compute <code>qa - qb</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L121-L126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:/-Tuple{LinearAlgebra.UniformScaling,Quaternion}" href="#Base.:/-Tuple{LinearAlgebra.UniformScaling,Quaternion}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function /(u::UniformScaling, q::Quaternion)
@inline function /(q::Quaternion, u::UniformScaling)</code></pre><p>Compute <code>qu/q</code> or <code>q/qu</code> (Hamilton product), in which <code>qu</code> is the scaled identity quaternion <code>qu = u.λ * I</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L225-L232">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:/-Tuple{Number,Quaternion}" href="#Base.:/-Tuple{Number,Quaternion}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function /(λ::Number, q::Quaternion)
@inline function /(q::Quaternion, λ::Number)</code></pre><p>Compute the division <code>λ/q</code> or <code>q/λ</code>, in which <code>λ</code> is a scalar.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L202-L208">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:/-Tuple{Quaternion,Quaternion}" href="#Base.:/-Tuple{Quaternion,Quaternion}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline /(q1::Quaternion, q2::Quaternion) = q1*inv(q2)</code></pre><p>Compute <code>q1*inv(q2)</code> (Hamilton product).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L217-L222">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:\\-Tuple{LinearAlgebra.UniformScaling,Quaternion}" href="#Base.:\\-Tuple{LinearAlgebra.UniformScaling,Quaternion}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function \(u::UniformScaling, q::Quaternion)
@inline function \(q::Quaternion, u::UniformScaling)</code></pre><p>Compute <code>inv(qu)*q</code> or <code>inv(q)*qu</code> (Hamilton product), in which <code>qu</code> is the scaled identity quaternion <code>qu = u.λ * I</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L258-L265">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:\\-Tuple{Quaternion,AbstractArray{T,1} where T}" href="#Base.:\\-Tuple{Quaternion,AbstractArray{T,1} where T}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline \(q::Quaternion, v::AbstractVector)
@inline \(v::AbstractVector, q::Quaternion)</code></pre><p>Compute <code>inv(q)*qv</code> or <code>inv(qv)*q</code> in which <code>qv</code> is a quaternion with real part <code>0</code> and vectorial/imaginary part <code>v</code> (Hamilton product).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L247-L254">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:\\-Tuple{Quaternion,Quaternion}" href="#Base.:\\-Tuple{Quaternion,Quaternion}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline \(q1::Quaternion, q2::Quaternion) = inv(q1)*q2</code></pre><p>Compute <code>inv(q1)*q2</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L239-L244">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.conj-Tuple{Quaternion}" href="#Base.conj-Tuple{Quaternion}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function conj(q::Quaternion)</code></pre><p>Compute the complex conjugate of the quaternion <code>q</code>:</p><pre><code class="language-none">q0 - q1.i - q2.j - q3.k</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L284-L291">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.copy-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.copy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function copy(q::Quaternion{T}) where T</code></pre><p>Create a copy of the quaternion <code>q</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L294-L299">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{Quaternion,Colon}" href="#Base.getindex-Tuple{Quaternion,Colon}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function getindex(q::Quaternion, ::Colon)</code></pre><p>Transform the quaternion into a 4x1 vector of type <code>T</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L272-L277">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.imag-Tuple{Quaternion}" href="#Base.imag-Tuple{Quaternion}"><code>Base.imag</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function imag(q::Quaternion)</code></pre><p>Return the vectorial or imaginary part of the quaternion <code>q</code> represented by a 3 × 1 vector of type <code>SVector{3}</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L302-L308">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.real-Tuple{Quaternion}" href="#Base.real-Tuple{Quaternion}"><code>Base.real</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function real(q::Quaternion)</code></pre><p>Return the real part of the quaternion <code>q</code>: <code>q0</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L337-L342">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show-Union{Tuple{T}, Tuple{IO,Quaternion{T}}} where T" href="#Base.show-Union{Tuple{T}, Tuple{IO,Quaternion{T}}} where T"><code>Base.show</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function show(io::IO, q::Quaternion{T}) where T</code></pre><p>Print the quaternion <code>q</code> to the stream <code>io</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L405-L410">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.zeros-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.zeros-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.zeros</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function zeros(q::Quaternion{T}) where T</code></pre><p>Create the null quaternion with the same type <code>T</code> of another quaternion <code>q</code>:</p><pre><code class="language-none">T(0) + T(0).i + T(0).j + T(0).k</code></pre><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q1 = Quaternion{Float32}(cosd(45/2),sind(45/2),0,0);

julia&gt; zeros(q1)
Quaternion{Float32}:
  + 0.0 + 0.0.i + 0.0.j + 0.0.k</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L381-L398">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.zeros-Union{Tuple{Type{Quaternion{T}}}, Tuple{T}} where T" href="#Base.zeros-Union{Tuple{Type{Quaternion{T}}}, Tuple{T}} where T"><code>Base.zeros</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function zeros(::Type{Quaternion{T}}) where T</code></pre><p>Create the null quaternion of type <code>T</code>:</p><pre><code class="language-none">T(0) + T(0).i + T(0).j + T(0).k</code></pre><p>If the type <code>T</code> is omitted, then it defaults to <code>Float64</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; zeros(Quaternion{Float32})
Quaternion{Float32}:
  + 0.0 + 0.0.i + 0.0.j + 0.0.k

julia&gt; zeros(Quaternion)
Quaternion{Float64}:
  + 0.0 + 0.0.i + 0.0.j + 0.0.k</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/54a210ec11f30e22abfb827500c6d4cb532fae47/src/quaternion.jl#L354-L375">source</a></section><footer><hr/><a class="previous" href="../../man/inv_rotations/"><span class="direction">Previous</span><span class="title">Inverting rotations</span></a></footer></article></body></html>
